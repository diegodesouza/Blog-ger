define("ember-bootstrap", ["ember-bootstrap/index","exports"], function(__index__, __exports__) {
  "use strict";
  Object.keys(__index__).forEach(function(key){
    __exports__[key] = __index__[key];
  });
});

define('ember-bootstrap/components/bs-alert', ['exports', 'ember', 'ember-bootstrap/mixins/type-class'], function (exports, Ember, TypeClass) {

    'use strict';

    exports['default'] = Ember['default'].Component.extend(TypeClass['default'], {
        classNameBindings: ['alert','fade','in'],

        /**
         * A dismissible alert will have a close button in the upper right corner, that the user can click to dismiss
         * the alert.
         *
         * @property dismissible
         * @type boolean
         * @default true
         * @public
         */
        dismissible: true,

        /**
         * If true the alert is completely hidden. Will be set when the fade animation has finished.
         *
         * @property dismissed
         * @type boolean
         * @default false
         * @readonly
         * @protected
         */
        dismissed: false,

        /**
         * This property indicates if the alert is visible. If false it might still be in the DOM until the fade animation
         * has completed. Can be set to change the visibility of the alert box.
         *
         * @property visible
         * @type boolean
         * @default true
         * @public
         */
        visible: true,

        /**
         * Set to false to disable the fade out animation when hiding the alert.
         *
         * @property fade
         * @type boolean
         * @default true
         * @public
         */
        fade: true,

        /**
         * Computed property to set the alert class to the component div. Will be false when dismissed to have the component
         * div (which cannot be removed form DOM by the component itself) without any markup.
         *
         * @property alert
         * @type boolean
         * @private
         */
        alert: Ember['default'].computed.not('dismissed'),
        in: Ember['default'].computed.and('visible','fade'),

        /**
         * @property classTypePrefix
         * @type String
         * @default 'alert'
         * @protected
         */
        classTypePrefix: 'alert',

        /**
         * The duration of the fade out animation
         *
         * @property fadeDuration
         * @type integer
         * @default 150
         * @public
         */
        fadeDuration: 150,

        actions: {
            dismiss: function() {
                this.hide();
            }
        },

        _onVisibleChange: Ember['default'].observer('visible', function() {
            if (this.get('visible')) {
                this.show();
            }
            else {
                this.hide();
            }
        }),

        /**
         * Call to make the alert visible again after it has been hidden
         *
         * @method show
         * @public
         */
        show: function() {
            this.setProperties({
                dismissed: false,
                visible: true
            });
        },

        /**
         * Call to hide the alert. If the `fade` property is true, this will fade out the alert before being finally
         * dismissed.
         *
         * @method hide
         * @public
         */
        hide: function() {
            if (this.get('fade')) {
                this.set('visible', false);
                Ember['default'].run.later(this,function() {
                    if (!this.get('isDestroyed')) {
                        this.set('dismissed', true);
                    }
                },this.get('fadeDuration'));
            }
            else {
                this.setProperties({
                    dismissed: true,
                    visible: false
                });
            }
        }


    });

});
define('ember-bootstrap/components/bs-button-group', ['exports', 'ember', 'ember-bootstrap/components/bs-button', 'ember-bootstrap/mixins/size-class'], function (exports, Ember, Button, SizeClass) {

    'use strict';

    exports['default'] = Ember['default'].Component.extend(SizeClass['default'], {

        /**
         * @type string
         * @property ariaRole
         * @default 'group'
         * @protected
         */
        ariaRole: 'group',

        /**
         * @property classNames
         * @type array
         * @default ['btn-group']
         * @protected
         */
        classNames: ['btn-group'],

        /**
         * @property classNameBindings
         * @type array
         * @protected
         */
        classNameBindings: ['vertical:btn-group-vertical','justified:btn-group-justified'],

        /**
         * @property classTypePrefix
         * @type String
         * @default 'btn-group'
         * @protected
         */
        classTypePrefix: 'btn-group',

        /**
         * Set to true for a vertically stacked button group, see http://getbootstrap.com/components/#btn-groups-vertical
         *
         * @property vertical
         * @type boolean
         * @default false
         * @public
         */
        vertical: false,

        /**
         * Set to true for the buttons to stretch at equal sizes to span the entire width of its parent.
         *
         * *Important*: You have to wrap every button component in a `div class="btn-group">`:
         *
         * ```handlebars
         * <div class="btn-group" role="group">
         * \{{#bs-button}}My Button{{/bs-button}}
         * </div>
         * ```
         *
         * See http://getbootstrap.com/components/#btn-groups-justified
         *
         * @property justified
         * @type boolean
         * @default false
         * @public
         */
        justified: false,

        /**
         * The type of the button group specifies how child buttons behave and how the `value` property will be computed:
         *
         * ### null
         * If `type` is not set (null), the button group will add no functionality besides Bootstrap styling
         *
         * ### radio
         * if `type` is set to "radio", the buttons will behave like radio buttons:
         * * the buttons will toggle (`toggle` property of the child buttons will be set to true)
         * * only one button may be active
         * * the `value` property of the button group will reflect the `value` property of the active button
         *
         * ### checkbox
         * if `type` is set to "checkbox", the buttons will behave like checkboxes:
         * * the buttons will toggle (`toggle` property of the child buttons will be set to true)
         * * any number of buttons may be active
         * * the `value` property of the button group will be an array containing the `value` properties of all active buttons
         *
         * @property type
         * @type string
         * @default null
         * @public
         */
        type: null,


        /**
         * The value of the button group, computed by its child buttons.
         * See the {{#crossLink "Button-Group/type:attribute"}}`type` property{{/crossLink}} for how the value property is constructed.
         *
         * When you set the value, the corresponding buttons will be activated:
         * * use a single value for a radio button group to activate the button with the same value
         * * use an aray of values for a checkbox button group to activate all the buttons with values contained in the array
         *
         * @property value
         * @type array|any
         * @public
         */
        value: Ember['default'].computed('activeChildren.@each.value','type',function(key, value){
            if (arguments.length>1) {
                var values = !Ember['default'].isArray(value) ? [value] : value;
                this.get('childButtons')
                    .forEach(function(button) {
                        button.set('active', values.contains(button.get('value')));
                    });
                return value;
            }
            switch (this.get('type')) {
                case 'radio':
                    return this.get('activeChildren.firstObject.value');
                case 'checkbox':
                    return this.get('activeChildren').mapBy('value');
            }
            return 1;
        }),

        /**
         * Array of all child buttons (instances of Bootstrap.Button)
         * @property childButtons
         * @type array
         * @protected
         */
        childButtons: Ember['default'].computed.filter('childViews', function(view) {
            return view instanceof Button['default'];
        }),


        /**
         * Child buttons that are active (pressed)
         * @property activeChildren
         * @type array
         * @protected
         */
        activeChildren: Ember['default'].computed.filterBy('childButtons', 'active', true),


        lastActiveChildren: [],
        newActiveChildren: Ember['default'].computed.setDiff('activeChildren','lastActiveChildren'),
        _observeButtons: Ember['default'].observer('activeChildren.[]','type', function() {
            if (this.get('type') !== 'radio') {
                return;
            }

            Ember['default'].run.scheduleOnce('actions',this, function(){
                // the button that just became active
                var newActive = this.get('newActiveChildren.firstObject');

                if (newActive) {
                    this.beginPropertyChanges();
                    this.get('childButtons').forEach(function(button){
                        if (button !== newActive) {
                            button.set('active', false);
                        }
                    });

                    this.endPropertyChanges();
                }
                // remember activeChildren, used as a replacement for a before observer as they will be deprecated in the future...
                this.set('lastActiveChildren', this.get('activeChildren').slice());
            });
        }),

        _observeType: Ember['default'].observer('type','childButtons.[]', function() {
            if (this.get('type') === 'radio' || this.get('type') === 'checkbox') {
                // set all child buttons to toggle
                this.get('childButtons').forEach(function(button) {
                    button.set('toggle', true);
                });
            }
        }),

        init: function() {
            this._super();
            this.get('activeChildren');
        }




    });

});
define('ember-bootstrap/components/bs-button', ['exports', 'ember', 'ember-bootstrap/mixins/type-class', 'ember-bootstrap/mixins/size-class'], function (exports, Ember, TypeClass, SizeClass) {

   'use strict';

   exports['default'] = Ember['default'].Component.extend(TypeClass['default'], SizeClass['default'], {
       tagName: 'button',

       /**
        * @property classNames
        * @type array
        * @default ['btn']
        * @protected
        */
       classNames: ['btn'],

       /**
        * @property classNameBindings
        * @type array
        * @default ['active', 'block:btn-block']
        * @protected
        */
       classNameBindings: ['active', 'block:btn-block'],

       /**
        * @property classTypePrefix
        * @type String
        * @default 'btn'
        * @protected
        */
       classTypePrefix: 'btn',

       /**
        * @property attributeBindings
        * @type array
        * @default ['id', 'disabled', 'buttonType:type']
        * @protected
        */
       attributeBindings: ['id', 'disabled', 'buttonType:type'],

       /**
        * Default label of the button. Not need if used as a block component
        *
        * @property defaultText
        */
       defaultText: null,

       /**
        * Property to disable the button
        *
        * @property disabled
        */
       disabled: false,

       /**
        * Set the type of the button, either 'button' or 'submit'
        *
        * @property buttonType
        * @type String
        * @default 'button'
        */
       buttonType: 'button',

       /**
        * Set the 'active' class to apply active/pressed CSS styling
        *
        * @property active
        * @type boolean
        * @default false
        */
       active: false,

       /**
        * Property for block level buttons
        *
        * See the [Bootstrap docs](http://getbootstrap.com/css/#buttons-sizes)
        * @property block
        * @type boolean
        * @default false
        */
       block: false,

       /**
        * If toggle property is true, clicking the button will toggle the active state
        *
        * @property toggle
        * @type boolean
        * @default false
        */
       toggle: false,

       /**
        * If button is active and this is set, the icon property will match this property
        *
        * @property iconActive
        * @type String
        */
       iconActive: null,

       /**
        * If button is inactive and this is set, the icon property will match this property
        *
        * @property iconInactive
        * @type String
        */
       iconInactive: null,

       /**
        * Class(es) (e.g. glyphicons or font awesome) to use as a button icon
        * This will render a <i class="{{icon}}"></i> element in front of the button's label
        *
        * @property icon
        * @type String
        */
       icon: Ember['default'].computed('active', function() {
           if (this.get('active')) {
               return this.get('iconActive');
           } else {
               return this.get('iconInactive');
           }
       }),


       /**
        * Supply a value that will be associated with this button. This will be send
        * as a parameter of the default action triggered when clicking the button
        *
        * @property value
        * @type any
        */
       value: null,

       /**
        * State of the button. The button's label (if not used as a block component) will be set to the
        * `<state>Text` property.
        * This property will automatically be set when using a click action that supplies the callback with an promise
        *
        * @property textState
        * @type String
        * @default 'default'
        */
       textState: 'default',

       /**
        * Set this to true to reset the state. A typical use case is to bind this attribute with ember-data isDirty flag.
        *
        * @property reset
        * @type boolean
        */
       reset: null,

       /**
        * This will reset the state property to 'default', and with that the button's label to defaultText
        *
        * @method resetState
        */
       resetState: function() {
           this.set('textState', 'default');
       },

       resetObserver: Ember['default'].observer('reset', function(){
           if(this.get('reset')){
               this.resetState();
           }
       }),

       text: Ember['default'].computed('textState', 'defaultText', 'pendingText', 'resolvedText', 'rejectedText', function() {
           return this.getWithDefault(this.get('textState') + 'Text', this.get('defaultText'));
       }),

       /**
        * Click handler. This will send the default "action" action, with the following parameters:
        * * value of the button (that is the value of the "value" property)
        * * original event object of the click event
        * * callback: call that with a promise object, and the buttons state will automatically set to "pending", "resolved" and/or "rejected"
        *
        * @method click
        * @protected
        * @param evt
        */
       click: function(evt) {
           if (this.get('toggle')) {
               this.toggleProperty('active');
           }
           var that = this;
           var callback = function(promise) {
               if (promise) {
                   that.set('textState', 'pending');
                   promise.then(
                       function(){
                           if (!that.get('isDestroyed')) {
                               that.set('textState', 'resolved');
                           }
                       },
                       function(){
                           if (!that.get('isDestroyed')) {
                               that.set('textState', 'rejected');
                           }
                       }
                   );
               }
           };
           this.sendAction('action', this.get('value'), evt, callback);
       }


   });

});
define('ember-bootstrap/components/bs-dropdown-button', ['exports', 'ember-bootstrap/components/bs-button', 'ember-bootstrap/mixins/dropdown-toggle'], function (exports, Button, DropdownToggle) {

	'use strict';

	exports['default'] = Button['default'].extend(DropdownToggle['default']);

});
define('ember-bootstrap/components/bs-dropdown-menu', ['exports', 'ember'], function (exports, Ember) {

    'use strict';

    exports['default'] = Ember['default'].Component.extend({
        tagName: 'ul',
        classNames: ['dropdown-menu'],
        classNameBindings: ['alignClass'],
        ariaRole: 'menu',

        align: 'left',

        alignClass: Ember['default'].computed('align', function() {
            if (this.get('align') !== 'left') {
                return 'dropdown-menu-' + this.get('align');
            }
        })


    });

});
define('ember-bootstrap/components/bs-dropdown-toggle', ['exports', 'ember', 'ember-bootstrap/mixins/dropdown-toggle'], function (exports, Ember, DropdownToggle) {

    'use strict';

    exports['default'] = Ember['default'].Component.extend(DropdownToggle['default'], {
        /**
         * Defaults to a `<a>` tag. Change for other types of dropdown toggles.
         *
         * @property tagName
         * @type string
         * @default "a"s
         * @public
         */
        tagName: 'a',


        attributeBindings: ['href'],

        /**
         * Computed property to generate a `href="#"` attribute when `tagName` is "a".
         *
         * @property href
         * @type string
         * @readonly
         * @protected
         */
        href: Ember['default'].computed('tagName', function(){
            if (this.get('tagName').toUpperCase() === 'A') {
                return '#';
            }
        }),


        click: function (e) {
            e.preventDefault();
            this.sendAction();
        }


    });

});
define('ember-bootstrap/components/bs-dropdown', ['exports', 'ember', 'ember-bootstrap/components/bs-dropdown-button'], function (exports, Ember, toggleButton) {

   'use strict';

   exports['default'] = Ember['default'].Component.extend({
       classNameBindings: ['open', 'containerClass'],

       /**
        * This property reflects the state of the dropdown, whether it is open or closed.
        *
        * @property open
        * @default false
        * @type boolean
        * @public
        */
       open: false,

       /**
        * By default clicking on an open dropdown menu will close it. Set this property to false for the menu to stay open.
        *
        * @property closeOnMenuClick
        * @default true
        * @type boolean
        * @public
        */
       closeOnMenuClick: true,

       /**
        * jQuery click event name, namespaced to this component's instance to prevent interference between multiple dropdowns.
        *
        * @property clickEventName
        * @type string
        * @private
        */
       clickEventName: undefined,

       /**
        * A computed property to generate the suiting class for the dropdown container, either "dropdown" or "btn-group".
        *
        * @property containerClass
        * @type string
        * @readonly
        * @protected
        */
       containerClass: Ember['default'].computed('toggleType', function(){
           return this.get('toggleType') === 'button' ? 'btn-group' : 'dropdown';
       }),

       /**
        * This property is "button" if the toggle element is an instance of `Bootstrap.DropdownButton`, otherwise "toggle".
        *
        * @property toggleType
        * @type string
        * @readonly
        * @protected
        */
       toggleType: Ember['default'].computed('childViews.@each', function() {
           if (this.get('childViews').any(function(view) {
               return view instanceof toggleButton['default'];
           })) {
               return 'button';
           }
           return 'toggle';
       }),

       actions: {
           toggleDropdown: function () {
               this.toggleProperty('open');
           },

           openDropdown: function () {
               this.set('open', true);
           },

           closeDropdown: function () {
               this.set('open', false);
           }
       },

       handleClickEvents: Ember['default'].observer('open', function() {
           if (this.get('open')) {
               Ember['default'].$(document).on(this.clickEventName, Ember['default'].run.bind(this, this.closeOnClickHandler));
           }
           else {
               Ember['default'].$(document).off(this.clickEventName);
           }
       }),

       willDestroyElement: function(){
           Ember['default'].$(document).off(this.clickEventName);
       },

       init: function() {
           this._super();
           // click event name that is namespaced to our component instance, so multiple dropdowns do not interfere
           // with each other
           this.clickEventName = 'click.' + this.get('elementId');
       },

       /**
        * Handler for click events to close the dropdown
        *
        * @method closeOnClickHandler
        * @param e
        * @protected
        */
       closeOnClickHandler: function(e) {
           var $target = Ember['default'].$(e.target);
           if(!this.get('isDestroyed') &&
               $target.closest(this.$().find('.dropdown-toggle')).length === 0 &&
               ($target.closest(this.$().find('.dropdown-menu')).length === 0 || this.get('closeOnMenuClick'))) {
               this.set('open', false);
           }
       }
   });

});
define('ember-bootstrap/mixins/dropdown-toggle', ['exports', 'ember'], function (exports, Ember) {

    'use strict';

    exports['default'] = Ember['default'].Mixin.create({
        classNames: ['dropdown-toggle'],
        attributeBindings: ['data-toggle'],
        ariaRole: 'button',
        'data-toggle': 'dropdown',

        targetObject: Ember['default'].computed.alias('parentView'),

        action: 'toggleDropdown'
    });

});
define('ember-bootstrap/mixins/size-class', ['exports', 'ember'], function (exports, Ember) {

    'use strict';

    exports['default'] = Ember['default'].Mixin.create({
        classTypePrefix: Ember['default'].required(String),
        classNameBindings: ['sizeClass'],
        sizeClass: (function() {
            var prefix = this.get('classTypePrefix'),
                size = this.get('size');
            return Ember['default'].isBlank(size) ? null : prefix + '-' + size;
        }).property('size'),


        /**
         * Property for size styling, set to 'lg', 'sm' or 'xs'
         *
         * Also see the [Bootstrap docs](http://getbootstrap.com/css/#buttons-sizes)
         *
         * @property size
         * @type String
         */
        size: null
    });

});
define('ember-bootstrap/mixins/type-class', ['exports', 'ember'], function (exports, Ember) {

    'use strict';

    exports['default'] = Ember['default'].Mixin.create({
        classTypePrefix: Ember['default'].required(String),
        classNameBindings: ['typeClass'],
        typeClass: (function() {
            var prefix = this.get('classTypePrefix'),
                type = this.get('type') || 'default';
            return prefix + '-' + type;
        }).property('type'),


        /**
         * Property for type styling
         *
         * For the available types see the [Bootstrap docs](http://getbootstrap.com/css/#buttons-options) (use without "btn-" prefix)
         *
         * @property type
         * @type String
         * @default 'default'
         */
        type: 'default'
    });

});//# sourceMappingURL=addons.map